'''
    N장의 카드
        - 차례로 1부터 N까지 넘버링
        - 1번이 제일 위에, N번이 제일 아래

    행동
        - 카드 한 장 남을 때 까지 반복
            - 제일 위에 있는 카드를 버린다.
            - 그 다음 제일 위에 있는 카드를 제일 아래로 옮긴다.

    제일 마지막에 남게 되는 카드를 구하시오.
'''

# [알고리즘]
# 데이터를 제거해야 하는데, 제거하는 위치가 가장 마지막 인덱스가 아니기 때문에 Q 사용

# [시간복잡도]
# 덱의 pop은 O(1) 연산
# 덱의 rotate은 k = abs(n) % len(deque), O(k) 연산, 아래 경우엔 k = 1 이므로, O(1)
# 입력 N에 따라서 반복 수가 달라지므로 O(N)
# 만약 아래 코드에서 rotate(-2)였다면, k = 2 이므로, 전체 코드의 시간 복잡도는 O(2N)
# 그러나 Big-O 표기에서 상수는 무시되므로 O(N)

from collections import deque

if __name__ == '__main__':
    # [0] 입력
    N = int(input())

    '''
        N장의 카드
            - 차례로 1부터 N까지 넘버링
            - 1번이 제일 위에, N번이 제일 아래
    '''

    DQ = deque(i for i in range(1, N+1))
    # N = 3 ---> DQ = [1,2,3]
    while DQ:
        # 종료 조건
        # - 카드 한 장 남을 때 까지 반복
        if len(DQ) == 1:
            break

        # [1] 제일 위에 있는 카드 버리기
        # [1-1] popleft()
        DQ.popleft()

        # [2] 제일 위에 있는 카드 제일 아래로 옮기기
        # [2-1] rotate(-1)
        DQ.rotate(-1)

    # [3] 출력
    print(DQ[0])
